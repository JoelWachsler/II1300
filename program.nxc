/*
.____                            ________                             ____  ______             _______________  ____ .________
|    |    ____   ____   ____    /  _____/______  ____  __ ________   /_   |/  __  \            \_____  \   _  \/_   ||   ____/
|    |  _/ __ \ / ___\ /  _ \  /   \  __\_  __ \/  _ \|  |  \____ \   |   |>      <    ______   /  ____/  /_\  \|   ||____  \
|    |__\  ___// /_/  >  <_> ) \    \_\  \  | \(  <_> )  |  /  |_> >  |   /   --   \  /_____/  /       \  \_/   \   |/       \
|_______ \___  >___  / \____/   \______  /__|   \____/|____/|   __/   |___\______  /           \_______ \_____  /___/______  /
        \/   \/_____/                  \/                   |__|                 \/                    \/     \/           \/
*/
/**
 * Author:      Joel Wachsler
 * Date:        2015-09-18
 * Desc:        Lego group 18 robot program for "KTH DROID WARS 2015".
 *              This program has a fully functioning AI.
 *
 * Disclaimer:  You are not allowed to use this program nor copy
 *              parts of it for use in the "KTH DROID WARS 2015"
 *              without the permission of all members of
 *              Lego Group 18.
 *
 **/

// Include definitions for NXC
#include "NXCDefs.h"

// Define speeds
#define HIGH_SPEED 100
#define MEDIUM_SPEED 50
#define SLOW_SPEED 25

// Define sonar rotation
#define US_ROT 35

// Define ways
#define RIGHT 0
#define LEFT 1
#define FORWARD 2
#define BACK 3

// Define threshhold value for the light sensor
#define THRESHOLD 40

// Define sonar sensitivity range
/*#define US_THRESHOLD 75*/
#define US_THRESHOLD 30

// Lock the motor to the task which acquire it
mutex motorMutex;

// Motor rotation counter for the sonar
short motorRotation = 0;
// The range of the ultrasonic sensor if it's
// shorter than the defined range for US_THRESHOLD
short sensorVal = 0;
// Found the initial target
bool target = false;
// Checks how many turns the motor for the
// ultra sonic sensor has rotated without
// finding a target
unsigned short sonarRotationCounter = 1;
// Lock the sonar in the inital position
bool total_sonar_lock = false;
// Check target lock
bool targetLock = false;
// Idle timer
unsigned short idleTimer = 0;

// TODO: PRIORITY CHECKING
// make tasks with higher priority override
// tasks/functions with lower priority

// Define all functions and task so they're
// usable by all functions
void rotate(bool direction, int deg);
void go(short way, short centimeter);
task check_line();
task rotate_sonar();
task sonar();
task random_movement();
task movement();
task strategy();


// Tell the robot to rotate
void rotate(bool direction, int deg)
{
    // Reset idletimer
    idleTimer = 0;

    // Lock sonar when going and rotating
    total_sonar_lock = true;

    // One degree is only a half one when rotating
    deg *= 2;

    // Holder for starting rotation
    int startingRotation = 0;

    // Left or Right
    // Left = true
    // Right = false
    if (direction)
    {
        startingRotation = MotorRotationCount(OUT_A);
        OnFwdSync(OUT_AB, HIGH_SPEED, -100);
        // Rotate until right rotation
        until(MotorRotationCount(OUT_A) > startingRotation + deg);
    }
    else
    {
        startingRotation = MotorRotationCount(OUT_B);
        OnFwdSync(OUT_AB, HIGH_SPEED, 100);
        // Rotate until right rotation
        until(MotorRotationCount(OUT_B) > startingRotation + deg);
    }

    // Brake the motor before exiting
    OffEx(OUT_AB, RESET_ALL);

    // Unlock sonar
    total_sonar_lock = false;
}

// Tell the robot to go in a certain way
void go(short way,  short centimeter)
{
    // Reset idletimer
    idleTimer = 0;

    // Converting
    int degrees = 50/3 * centimeter;
    int startingRotation = MotorRotationCount(OUT_A);

    // Lock sonar when going and rotating
    total_sonar_lock = true;

    switch(way)
    {
        case FORWARD:
            // Start motor and sync them
            OnFwdSync(OUT_AB, HIGH_SPEED, 0);
            // Rotate until right rotation
            // TODO: TEST this
            until(MotorRotationCount(OUT_A) > startingRotation + degrees || !target);
            /*until(MotorRotationCount(OUT_A) > startingRotation + degrees);*/
            break;
        case BACK:
            OnFwdSync(OUT_AB, -HIGH_SPEED, 0);
            until(MotorRotationCount(OUT_A) < startingRotation - degrees);
            break;
        case LEFT:
            // TODO: MAKE LEFT AND RIGHT GO IN A CIRCLE WITH
            // A DIAMETER OF 20 CM
            OnFwd(OUT_A, HIGH_SPEED);
            OnFwd(OUT_B, MEDIUM_SPEED);
            until(MotorRotationCount(OUT_A) > startingRotation + degrees);
            break;
        case RIGHT:
            OnFwd(OUT_A, MEDIUM_SPEED);
            OnFwd(OUT_B, HIGH_SPEED);
            until(MotorRotationCount(OUT_B) > startingRotation + degrees);
            break;
    }

    // Reset rotation counter and turn off the motor
    OffEx(OUT_AB, RESET_ALL);

    // Unlock sonar
    total_sonar_lock = false;
}

// Check so we don't pass the line
task check_line()
{
    // Set light sensor at port 3
    SetSensorLight(IN_3);

    // Constantly check the value of the light sensor
    while (true)
    {
        // Don't overload the cpu!
        Wait(50);

        // Check light value
        if (Sensor(IN_3) > THRESHOLD)
            continue;

        // Don't let other programs control the motor
        Acquire(motorMutex);

        // We need to find the target again after finishing
        // this task
        target = false;

        // Go back a little bit before turning
        go(BACK, 10);
        // Random left or right
        rotate((Random(2) & 1) ? LEFT : RIGHT, 180);

        // Release the motor
        Release(motorMutex);

        // This function is too slow!
        /*RotateMotorEx(OUT_AB, HIGH_SPEED, -180, 0, true, true);*/
        // If the other robot is not in the range of -120 and 120 degrees
        // turn either left or right
        /*if (motorRotation > -120 && motorRotation < 120)*/
            /*// Random if turning left or right*/
            /*RotateMotorEx(OUT_AB, ((Random(2) & 0 ) ? -1 : 1)*HIGH_SPEED, 460, -100, true, true);*/
        /*else*/
            /*// Turn to the direction the other robot is*/
            /*RotateMotorEx(OUT_AB, HIGH_SPEED, (460/360)*motorRotation, -100, true, true);*/
    }
}

inline void left_right_or_lock(int startingRotation, int rotate, bool left_right)
{
    if (left_right)
    {
        OnFwd(OUT_C, US_ROT);
        until(MotorRotationCount(OUT_C) > startingRotation + rotate || total_sonar_lock);
    }
    else
    {
        OnFwd(OUT_C, -US_ROT);
        until(MotorRotationCount(OUT_C) < startingRotation - rotate || total_sonar_lock);
    }
}

task rotate_sonar()
{
    Follows(strategy);

    // Reset motor position
    int startingRotation = MotorRotationCount(OUT_C);
    int rotate = sonarRotationCounter * 40;

    while (true)
    {
        // Rotate a low number of degrees when locked
        while (total_sonar_lock)
        {
            OnFwd(OUT_C, -HIGH_SPEED);
            until(MotorRotationCount(OUT_C) < startingRotation + 10);

            OnFwd(OUT_C, HIGH_SPEED);
            until(MotorRotationCount(OUT_C) > startingRotation - 10);
        }

        // Calulcate turn with a maximum of 180 degrees
        rotate = (sonarRotationCounter * 40 >= 180) ? 180 : sonarRotationCounter * 40;

        // Rotate left and right
        if (Random(2) & 1)
        {
            left_right_or_lock(startingRotation, rotate, LEFT);
            left_right_or_lock(startingRotation, rotate, RIGHT);
        }
        else
        {
            left_right_or_lock(startingRotation, rotate, RIGHT);
            left_right_or_lock(startingRotation, rotate, LEFT);
        }

        // Search for more than one
        sonarRotationCounter++;
    }
}

task sonar()
{
    // The sonar can't detect in less than 150ms
    SetSensorLowspeed(IN_4);

    while(true)
    {
        // Don't overload the CPU!
        Wait(150);
        // Update sonar sensor value
        sensorVal = SensorUS(IN_4);

        // Only detect values over the threshold
        if (sensorVal > US_THRESHOLD)
        {
            // Remove the target lock
            target = false;
            continue;
        }

        // FOUND A TARGET!
        motorRotation = MotorRotationCount(OUT_C);
        target = true;
        sonarRotationCounter = 1;

        // True while looking at target
        // For dropping movement if the target
        // disappears while moving towards it
        targetLock = true;
    }
}

task random_movement()
{
    // Random timer min and max time
    unsigned short starting = 10000;
    unsigned short ending = 25000;

    unsigned short start_rotation = 20;
    unsigned short end_rotation = 180;

    unsigned short start_forward = 5;
    unsigned short end_forward = 20;

    while (true)
    {
        // Do something random if standing still
        // for a couple of seconds
        if (idleTimer <= Random(ending-starting)+starting)
        {
            Wait(500);
            idleTimer += 500;
            continue;
        }

        // Randomizing movement when idle

        if (Random(2) & 1)
            rotate((Random(2) & 1) ? LEFT : RIGHT, Random(end_rotation-start_rotation)+start_rotation);
        else
            go(FORWARD, Random(end_forward-start_forward)+start_forward);
    }
}

task movement()
{
    Follows(strategy);

    while(true)
    {
        // We need to find a target before doing anything
        if (!target)
            continue;

        // Go forward if between -10 and 10 degrees
        if(motorRotation > -25 && motorRotation < 25)
            go(FORWARD, sensorVal + 10);
            // Rotate left if positive
        else if(motorRotation > 0)
            // Rotate right if negative
            rotate(LEFT, motorRotation);
        else if(motorRotation < 0)
            // Number is negative, convert
            rotate(RIGHT, abs(motorRotation));

        // A new target has to be found!
        target = false;
    }
}

// Randomizes strategy so the other player can't
// counter us by looking at a stratergy this robot
// uses in a certain round
task strategy()
{
    // By having the different strats in an array
    // we can easily disable them
    int strats[] = {
        1,
        2,
        3,
        4,
        5
    };

    // Pick a random strat from the array
    switch(strats[Random(ArrayLen(strats))])
    {
        case 1:
            // Rotate right and just push the other player
            // out of the ring
            rotate(RIGHT, 90);
            go(FORWARD, 50);
            break;
        case 2:
            // Go forwards right and then up, pushing the other
            // robot from the back
            go(FORWARD, 20);
            // TODO: Make 180 degrees right do an arc with a diameter
            // of 20 cm
            go(RIGHT, 180);
            go(FORWARD, 50);
            break;
        case 3:
            // Go around the other robot so we position our front
            // to the other one's left side and push them
            go(RIGHT, 90);
            go(FORWARD, 30);
            go(RIGHT, 90);
            go(FORWARD, 50);
            break;
        case 4:
            // Try to counter the other if they try strat#1
            // Go backwards and then forwards pushing the
            // other robot off the field
            go(BACK, 50);
            go(FORWARD, 100);
            break;
        case 5:
            // Rotate 360 degrees as fast a possible and
            // try to find the other robot
            rotate((Random(2) & 1) ? LEFT : RIGHT, 360);
            break;
    }
}

task main()
{
    // Start tasks
    Precedes(
                /*strategy*/
                /*check_line,*/
                sonar,
                /*rotate_sonar,*/
                movement
                /*random_movement*/
            );
}
