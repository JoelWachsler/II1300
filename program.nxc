/**
 * Author:  Joel Wachsler
 * Date:    2015-09-15
 * Desc:    Lego group 18 robot program for wrestling match
 **/

// Include definitions for NXC
#include "NXCDefs.h"

// Define speeds
#define HIGH_SPEED 100
#define MEDIUM_SPEED 50
#define SLOW_SPEED 25

// Define sonar rotation
#define US_ROT 35

// Define ways
#define RIGHT 0
#define LEFT 1
#define FORWARD 2
#define BACK 3

// Define threshhold value for the light sensor
#define THRESHOLD 40

// Define sonar sensitivity range
#define US_THRESHOLD 75

// Motor rotation
short motorRotation = 0;
// Value of sensor
short sensorVal = 0;
// Found the initial target
bool target = false;
short targetCounter = 1;
// SONAR LOCK
bool sonar_lock = false;
// Lock the sonar in the inital position
bool total_sonar_lock = false;

// Tell the robot to rotate
void rotate(bool direction, int deg)
{
    // One degree is only a half one when rotating
    deg *= 2;

    // Holder for starting rotation
    int startingRotation = 0;

    // Left or Right
    // Left = true
    // Right = false
    if (direction)
    {
        startingRotation = MotorRotationCount(OUT_A);
        OnFwdSync(OUT_AB, HIGH_SPEED, -100);
        // Rotate until right rotation
        until(MotorRotationCount(OUT_A) > startingRotation + deg);
    }
    else
    {
        startingRotation = MotorRotationCount(OUT_B);
        OnFwdSync(OUT_AB, HIGH_SPEED, 100);
        // Rotate until right rotation
        until(MotorRotationCount(OUT_B) > startingRotation + deg);
    }

    // Brake the motor before exiting
    OffEx(OUT_AB, RESET_ALL);
}

// Tell the robot to go in a certain way
void go(short way, short centimeter)
{
    // Converting
    int degrees = 50/3 * centimeter;
    int startingRotation = MotorRotationCount(OUT_A);

    switch(way)
    {
        case FORWARD:
            // Start motor and sync them
            sonar_lock = true;
            total_sonar_lock = true;
            OnFwdSync(OUT_AB, HIGH_SPEED, 0);
            // Rotate until right rotation
            until(MotorRotationCount(OUT_A) > startingRotation + degrees);
            // Unlock sonar
            total_sonar_lock = false;
            break;
        case BACK:
            OnFwdSync(OUT_AB, -HIGH_SPEED, 0);
            until(MotorRotationCount(OUT_A) < startingRotation - degrees);
            break;
        case LEFT:
            OnFwd(OUT_A, HIGH_SPEED);
            OnFwd(OUT_B, MEDIUM_SPEED);
            until(MotorRotationCount(OUT_A) > startingRotation + degrees);
            break;
        case RIGHT:
            OnFwd(OUT_A, MEDIUM_SPEED);
            OnFwd(OUT_B, HIGH_SPEED);
            until(MotorRotationCount(OUT_B) > startingRotation + degrees);
            break;
    }

    // Reset rotation counter and turn off the motor
    OffEx(OUT_AB, RESET_ALL);
}

// Check so we don't pass the line
task check_line()
{
    // Set light sensor at port 3
    SetSensorLight(IN_3);

    // Constantly check the value of the light sensor
    while (true)
    {
        // Check light value
        if (Sensor(IN_3) < THRESHOLD)
        {
            // Go in reversed direction!
            // TAKE CONTROL OVER THE MOTOR

            // We need to find the target again after finishing this
            target = false;

            // Go back a little bit before turning
            RotateMotorEx(OUT_AB, HIGH_SPEED, -180, 0, true, true);
            // If the other robot is not in the range of -120 and 120 degrees
            // turn either left or right
            if (motorRotation > -120 && motorRotation < 120)
                // Random if turning left or right
                if (Random(1) == 0)
                    // Turn right
                    RotateMotorEx(OUT_AB, HIGH_SPEED, 460, -100, true, true);
                else
                    // Turn left
                    RotateMotorEx(OUT_AB, HIGH_SPEED, -460, -100, true, true);

            else
                // Turn to the direction the other robot is
                RotateMotorEx(OUT_AB, HIGH_SPEED, (460/360)*motorRotation, -100, true, true);

        }

        // Don't overload the cpu!
        Wait(50);
    }
}

task rotate_sonar()
{
    // Reset motor position
    int startingRotation = MotorRotationCount(OUT_C);
    int rotate = targetCounter * 40;

    bool firstRotation = true;

    while (true)
    {
        while (total_sonar_lock)
        {
            OnFwd(OUT_C, -HIGH_SPEED);
            until(MotorRotationCount(OUT_C) < startingRotation + 10);

            OnFwd(OUT_C, HIGH_SPEED);
            until(MotorRotationCount(OUT_C) > startingRotation - 10);
        }

        if (!sonar_lock)
        {
            // Calulcate turn
            rotate = (targetCounter * 40 >= 180) ? 180 : targetCounter * 40;

            if (firstRotation)
            {
                OnFwd(OUT_C, -US_ROT);
                until(MotorRotationCount(OUT_C) < startingRotation - 180 || sonar_lock);

                // Only do the first rotation once
                firstRotation = false;
            }

            // Rotate left and right
            if (Random(2) == 0)
            {
                OnFwd(OUT_C, -US_ROT);
                until(MotorRotationCount(OUT_C) < startingRotation - rotate || sonar_lock);
                OnFwd(OUT_C, US_ROT);
                until(MotorRotationCount(OUT_C) > startingRotation + rotate || sonar_lock);
            }
            else
            {
                OnFwd(OUT_C, US_ROT);
                until(MotorRotationCount(OUT_C) > startingRotation + rotate || sonar_lock);
                OnFwd(OUT_C, -US_ROT);
                until(MotorRotationCount(OUT_C) < startingRotation - rotate || sonar_lock);
            }

            // Search for more than one
            targetCounter++;

            /*if (sonar_lock)*/
                /*continue;*/

        }
        else
        {
            // Rotate back to inital position
            sonar_lock = false;
            if (MotorRotationCount(OUT_C) > 0)
            {
                OnFwd(OUT_C, -HIGH_SPEED);
                until(MotorRotationCount(OUT_C) <= startingRotation);
            }
            else
            {
                OnFwd(OUT_C, HIGH_SPEED);
                until(MotorRotationCount(OUT_C) >= startingRotation);
            }

            RotateMotor(OUT_C, 100, -MotorRotationCount(OUT_C));
            Off(OUT_C);
        }
    }
}

task sonar()
{
    SetSensorLowspeed(IN_4);

    while(true)
    {
        // Don't overload the CPU!
        Wait(150);
        ClearScreen();
        sensorVal = SensorUS(IN_4);

        // Only detect values over the threshold
        if (sensorVal < US_THRESHOLD)
        {
            // FOUND A TARGET!
            motorRotation = MotorRotationCount(OUT_C);
            target = true;
            targetCounter = 0;
        }

        // Print values to screen
        /*NumOut(0, 0, sensorVal);*/
        /*NumOut(0, 10, motorRotation);*/
        /*NumOut(0, 20, MotorRotationCount(OUT_C));*/
    }
}

task movement()
{
    // We need to find a target before doing anything
    while(true)
    {
        if (target)
        {
            ClearScreen();
            NumOut(0, 10, motorRotation);

            // Go forward if between -10 and 10 degrees
            if(motorRotation > -25 && motorRotation < 25)
            {
                go(FORWARD, sensorVal + 10);
                // Rotate left if positive
            }
            else if(motorRotation > 0)
            {
                // Rotate right if negative
                sonar_lock = true;
                total_sonar_lock = true;
                rotate(LEFT, motorRotation);
                total_sonar_lock = false;
            }
            else if(motorRotation < 0)
            {
                // Number is negative, convert
                sonar_lock = true;
                total_sonar_lock = true;
                rotate(RIGHT, abs(motorRotation));
                total_sonar_lock = false;
            }

            // A new target has to be found!
            target = false;
        }
    }
}

task main()
{
    // Start tasks
    Precedes(
                sonar,
                rotate_sonar,
                movement
                /*check_line*/
                );
}
