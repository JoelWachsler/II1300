/**
 * Author:  Joel Wachsler
 * Date:    2015-09-14
 * Desc:    Lego group 18 robot program for wrestling match
 **/

// Include definitions for NXC
#include "NXCDefs.h"

// Define where everything is connected
#define ULTRASONIC 1
#define EYES 1
#define LIGHT 2
#define SOUND 3
#define MIC 3
#define TOUCH 4

// Define speeds
#define HIGH_SPEED 100
#define MEDIUM_SPEED 50
#define SLOW_SPEED 25

// Define ways
#define FORWARD 0
#define RIGHT 1
#define BACK 2
#define LEFT 3

// Define rotation directions
#define ROTATE_RIGHT 1
#define ROTATE_LEFT 0

// Define threshhold value for the light sensor
#define THRESHOLD 40

// Define sonar sensitivity range
#define US_THRESHOLD 150

// Tell the robot to rotate
void rotate(int deg, bool direction)
{
    // Holder for starting rotation
    int startingRotation = 0;
    // Right or left
    // Right = true
    // Left = false
    if (direction)
    {
        startingRotation = MotorRotationCount(OUT_A);
        OnFwdSync(OUT_AB, HIGH_SPEED, -100);
        // Rotate until right rotation
        until(MotorRotationCount(OUT_A) > startingRotation + deg);
    }
    else
    {
        startingRotation = MotorRotationCount(OUT_B);
        OnFwdSync(OUT_AB, HIGH_SPEED, 100);
        // Rotate until right rotation
        until(MotorRotationCount(OUT_B) > startingRotation + deg);
    }

    // Brake the motor before exiting
    OffEx(OUT_AB, RESET_ALL);
}

// Tell the robot to go in a certain way
void go(short way, short rotations)
{
    int startingRotation = MotorRotationCount(OUT_A);
    switch(way)
    {
        case FORWARD:
            // Start motor and sync them
            OnFwdSync(OUT_AB, HIGH_SPEED, 0);
            // Rotate until right rotation
            until(MotorRotationCount(OUT_A) > startingRotation + rotations);
            break;
        case LEFT:
            OnFwdSync(OUT_AB, HIGH_SPEED, -50);
            until(MotorRotationCount(OUT_A) > startingRotation + rotations);
            break;
        case RIGHT:
            OnFwdSync(OUT_AB, HIGH_SPEED, 50);
            until(MotorRotationCount(OUT_B) > startingRotation + rotations);
            break;
        case BACK:
            OnFwdSync(OUT_AB, -HIGH_SPEED, 50);
            until(MotorRotationCount(OUT_B) > startingRotation + rotations);
            break;
    }

    OffEx(OUT_AB, RESET_ALL);
}

// Check so we don't pass the line
task check_line()
{
    // Change so the light sensor returns its value in percentage
    /*SetSensor(LIGHT, SENSOR_MODE_PERCENT);*/
    // Set light sensor at port 3
    SetSensorLight(IN_3);

    // Constantly check the value of the light sensor
    while (true)
    {
        // Check light value
        if (Sensor(IN_3) > THRESHOLD)
        {
            // Go in reversed direction!
            // TAKE CONTROL OVER THE MOTOR

            // Go back a little bit before turning
            RotateMotorEx(OUT_AB, 100, 360, 0, true, true);
            // And now turn 180 degrees
            // TODO: Change later so we rotate the right way!
            RotateMotorEx(OUT_AB, 100, 180, -100, true, true);
        }

        // Don't overload the cpu!
        Wait(100);
    }
}

// Check if the sensor can see anything at the current point
bool us_see()
{
    // Check if the sonar sees anything
    return (SensorUS(IN_4) < US_THRESHOLD) ? true : false;
}

// This function will lock the UltraSonic sensor to the target
void lock()
{
}

task sonar()
{
    // Set sensor ultrasonic to sensor 4
    SetSensorLowspeed(IN_4);
    int startingRotation = MotorRotationCount(OUT_C);

    while (true)
    {
        // Turn right 360 degrees or untill it detecs something
        OnFwd(OUT_C, SLOW_SPEED);
        until(MotorRotationCount(OUT_C) > startingRotation + 360 || SensorUS(IN_4) < US_THRESHOLD);
        Off(OUT_C);

        if (us_see())
            // Temp break to see if it finds anything
            break;

        // Turn right 360 degrees or untill it detecs something
        OnFwd(OUT_C, -SLOW_SPEED);
        until(MotorRotationCount(OUT_C) < startingRotation + 360 || SensorUS(IN_4) < US_THRESHOLD);
        Off(OUT_C);

        // Don't overload the CPU!
        Wait(100);

        if (us_see())
            // Temp break to see if it finds anything
            break;
    }
}

task main()
{
    /**
     *  TODO: Calculate which way to rotate
     **/
    // Start tasks
    /*Precedes(check_line, sonar);*/

    // Testing to see if everything works!
    rotate(360, ROTATE_RIGHT);
    go(FORWARD, 2);
    rotate(180, ROTATE_LEFT);
    go(LEFT, 1);
    go(RIGHT, 1);
}
