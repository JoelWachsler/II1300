/*
.____                            ________                             ____  ______             _______________  ____ .________
|    |    ____   ____   ____    /  _____/______  ____  __ ________   /_   |/  __  \            \_____  \   _  \/_   ||   ____/
|    |  _/ __ \ / ___\ /  _ \  /   \  __\_  __ \/  _ \|  |  \____ \   |   |>      <    ______   /  ____/  /_\  \|   ||____  \
|    |__\  ___// /_/  >  <_> ) \    \_\  \  | \(  <_> )  |  /  |_> >  |   /   --   \  /_____/  /       \  \_/   \   |/       \
|_______ \___  >___  / \____/   \______  /__|   \____/|____/|   __/   |___\______  /           \_______ \_____  /___/______  /
        \/   \/_____/                  \/                   |__|                 \/                    \/     \/           \/
*/
/**
 * Author:      Joel Wachsler
 * Date:        2015-09-18
 * Desc:        Lego group 18 robot program for "KTH DROID WARS 2015".
 *              This program has a fully functioning AI.
 *
 * Disclaimer:  You are not allowed to use this program nor copy
 *              parts of it for use in the "KTH DROID WARS 2015"
 *              without the permission of all members of
 *              Lego Group 18.
 *
 **/

// Include definitions for NXC
#include "NXCDefs.h"

// Define speeds
#define HIGH_SPEED 100
#define MEDIUM_SPEED 50
#define SLOW_SPEED 25

// Define sonar rotation
#define US_ROT 35

// Define ways
#define RIGHT 0
#define LEFT 1
#define FORWARD 2
#define BACK 3

// Define threshhold value for the light sensor
#define THRESHOLD 40

// Define sonar sensitivity range
#define US_THRESHOLD 75

// Motor rotation
short motorRotation = 0;
// Value of sensor
short sensorVal = 0;
// Found the initial target
bool target = false;
unsigned short targetCounter = 1;
// Lock the sonar in the inital position
bool total_sonar_lock = false;
// Check target lock
bool targetLock = false;
// Idle timer
unsigned short idleTimer = 0;

// Tell the robot to rotate
void rotate(bool direction, int deg)
{
    // Reset idletimer
    idleTimer = 0;

    // Lock sonar when going and rotating
    total_sonar_lock = true;

    // One degree is only a half one when rotating
    deg *= 2;

    // Holder for starting rotation
    int startingRotation = 0;

    // Left or Right
    // Left = true
    // Right = false
    if (direction)
    {
        startingRotation = MotorRotationCount(OUT_A);
        OnFwdSync(OUT_AB, HIGH_SPEED, -100);
        // Rotate until right rotation
        until(MotorRotationCount(OUT_A) > startingRotation + deg);
    }
    else
    {
        startingRotation = MotorRotationCount(OUT_B);
        OnFwdSync(OUT_AB, HIGH_SPEED, 100);
        // Rotate until right rotation
        until(MotorRotationCount(OUT_B) > startingRotation + deg);
    }

    // Brake the motor before exiting
    OffEx(OUT_AB, RESET_ALL);

    // Unlock sonar
    total_sonar_lock = false;
}

// Tell the robot to go in a certain way
void go(short way, short centimeter)
{
    // Reset idletimer
    idleTimer = 0;

    // Converting
    int degrees = 50/3 * centimeter;
    int startingRotation = MotorRotationCount(OUT_A);

    // Lock sonar when going and rotating
    total_sonar_lock = true;

    switch(way)
    {
        case FORWARD:
            // Start motor and sync them
            OnFwdSync(OUT_AB, HIGH_SPEED, 0);
            // Rotate until right rotation
            until(MotorRotationCount(OUT_A) > startingRotation + degrees || !targetLock);
            break;
        case BACK:
            OnFwdSync(OUT_AB, -HIGH_SPEED, 0);
            until(MotorRotationCount(OUT_A) < startingRotation - degrees);
            break;
        case LEFT:
            OnFwd(OUT_A, HIGH_SPEED);
            OnFwd(OUT_B, MEDIUM_SPEED);
            until(MotorRotationCount(OUT_A) > startingRotation + degrees);
            break;
        case RIGHT:
            OnFwd(OUT_A, MEDIUM_SPEED);
            OnFwd(OUT_B, HIGH_SPEED);
            until(MotorRotationCount(OUT_B) > startingRotation + degrees);
            break;
    }

    // Reset rotation counter and turn off the motor
    OffEx(OUT_AB, RESET_ALL);

    // Unlock sonar
    total_sonar_lock = false;
}

// Check so we don't pass the line
task check_line()
{
    // Set light sensor at port 3
    SetSensorLight(IN_3);

    // Constantly check the value of the light sensor
    while (true)
    {
        // Don't overload the cpu!
        Wait(50);

        // Check light value
        if (Sensor(IN_3) > THRESHOLD)
            continue;

        // Go in reversed direction!
        // TAKE CONTROL OVER THE MOTOR

        // We need to find the target again after finishing this
        target = false;

        // Go back a little bit before turning
        RotateMotorEx(OUT_AB, HIGH_SPEED, -180, 0, true, true);
        // If the other robot is not in the range of -120 and 120 degrees
        // turn either left or right
        if (motorRotation > -120 && motorRotation < 120)
            // Random if turning left or right
            RotateMotorEx(OUT_AB, ((Random(2) & 0 ) ? -1 : 1)*HIGH_SPEED, 460, -100, true, true);
        else
            // Turn to the direction the other robot is
            RotateMotorEx(OUT_AB, HIGH_SPEED, (460/360)*motorRotation, -100, true, true);
    }
}

inline void left_right_or_lock(int startingRotation, int rotate, bool left_right)
{
    if (left_right)
    {
        OnFwd(OUT_C, US_ROT);
        until(MotorRotationCount(OUT_C) > startingRotation + rotate || total_sonar_lock);
    }
    else
    {
        OnFwd(OUT_C, -US_ROT);
        until(MotorRotationCount(OUT_C) < startingRotation - rotate || total_sonar_lock);
    }
}

task rotate_sonar()
{
    // Reset motor position
    int startingRotation = MotorRotationCount(OUT_C);
    int rotate = targetCounter * 40;

    // Go to the right the first rotation
    left_right_or_lock(startingRotation, 180, RIGHT);

    while (true)
    {
        // Rotate a low number of degrees when locked
        while (total_sonar_lock)
        {
            OnFwd(OUT_C, -HIGH_SPEED);
            until(MotorRotationCount(OUT_C) < startingRotation + 10);

            OnFwd(OUT_C, HIGH_SPEED);
            until(MotorRotationCount(OUT_C) > startingRotation - 10);
        }

        // Calulcate turn
        rotate = (targetCounter * 40 >= 180) ? 180 : targetCounter * 40;

        // Rotate left and right
        if (Random(2) & 1)
        {
            left_right_or_lock(startingRotation, rotate, LEFT);
            left_right_or_lock(startingRotation, rotate, RIGHT);
        }
        else
        {
            left_right_or_lock(startingRotation, rotate, RIGHT);
            left_right_or_lock(startingRotation, rotate, LEFT);
        }

        // Search for more than one
        targetCounter++;
    }
}

task sonar()
{
    // The sonar can't detect in less than 150ms
    SetSensorLowspeed(IN_4);

    while(true)
    {
        // Don't overload the CPU!
        Wait(150);
        // Update sonar sensor value
        sensorVal = SensorUS(IN_4);

        // Only detect values over the threshold
        if (sensorVal > US_THRESHOLD)
        {
            // Remove the target lock
            target = false;
            continue;
        }

        // FOUND A TARGET!
        motorRotation = MotorRotationCount(OUT_C);
        target = true;
        targetCounter = 0;

        // True while looking at target
        // For dropping movement if the target
        // disappears while moving towards it
        targetLock = true;
    }
}

task random_movement()
{
    // Random timer min and max time
    int starting = 10000;
    int ending = 25000;

    short start_rotation = 30;
    short end_rotation = 30;

    short start_forward = 50;
    short end_forward = 5;

    while (true)
    {
        // Do something random if standing still
        // for a couple of seconds
        if (idleTimer <= Random(ending-starting)+starting)
        {
            Wait(500);
            idleTimer += 500;
            continue;
        }

        // Randomizing movement when idle
        if (Random(2) & 1)
            rotate((Random(2) & 1) ? LEFT : RIGHT, Random(end_rotation-start_rotation)+start_rotation);
        else
            go(FORWARD, Random(end_forward-start_forward)+start_forward);
    }
}

task movement()
{
    while(true)
    {
        // We need to find a target before doing anything
        if (!target)
            continue;

        // Go forward if between -10 and 10 degrees
        if(motorRotation > -25 && motorRotation < 25)
            go(FORWARD, sensorVal + 10);
            // Rotate left if positive
        else if(motorRotation > 0)
            // Rotate right if negative
            rotate(LEFT, motorRotation);
        else if(motorRotation < 0)
            // Number is negative, convert
            rotate(RIGHT, abs(motorRotation));

        // A new target has to be found!
        target = false;
    }
}

task main()
{
    // Start tasks
    Precedes(
                sonar,
                rotate_sonar,
                movement,
                random_movement
                /*check_line*/
                );
}
