/**
 * Author:  Joel Wachsler
 * Date:    2015-09-15
 * Desc:    Lego group 18 robot program for wrestling match
 **/

// Include definitions for NXC
#include "NXCDefs.h"

// Define speeds
#define HIGH_SPEED 100
#define MEDIUM_SPEED 50
#define SLOW_SPEED 25

// Define ways
#define RIGHT 0
#define LEFT 1
#define FORWARD 2
#define BACK 3

// Define threshhold value for the light sensor
#define THRESHOLD 40

// Define sonar sensitivity range
#define US_THRESHOLD 150

// Motor rotation
short motorRotation = 0;
// Value of sensor
short sensorVal = 0;
// Found the initial target
bool target = false;

// Tell the robot to rotate
void rotate(bool direction, int deg)
{
    // One degree is only a half one when rotating
    deg *= 2;

    // Holder for starting rotation
    int startingRotation = 0;

    // Left or Right
    // Left = true
    // Right = false
    if (direction)
    {
        startingRotation = MotorRotationCount(OUT_A);
        OnFwdSync(OUT_AB, HIGH_SPEED, -100);
        // Rotate until right rotation
        until(MotorRotationCount(OUT_A) > startingRotation + deg);
    }
    else
    {
        startingRotation = MotorRotationCount(OUT_B);
        OnFwdSync(OUT_AB, HIGH_SPEED, 100);
        // Rotate until right rotation
        until(MotorRotationCount(OUT_B) > startingRotation + deg);
    }

    // Brake the motor before exiting
    OffEx(OUT_AB, RESET_ALL);
}

// Tell the robot to go in a certain way
void go(short way, short centimeter)
{
    // Converting
    int degrees = 50/3 * centimeter;
    int startingRotation = MotorRotationCount(OUT_A);

    switch(way)
    {
        case FORWARD:
            // Start motor and sync them
            OnFwdSync(OUT_AB, HIGH_SPEED, 0);
            // Rotate until right rotation
            until(MotorRotationCount(OUT_A) > startingRotation + degrees);
            break;
        case BACK:
            OnFwdSync(OUT_AB, -HIGH_SPEED, 0);
            until(MotorRotationCount(OUT_A) < startingRotation - degrees);
            break;
        case LEFT:
            OnFwd(OUT_A, HIGH_SPEED);
            OnFwd(OUT_B, MEDIUM_SPEED);
            until(MotorRotationCount(OUT_A) > startingRotation + degrees);
            break;
        case RIGHT:
            OnFwd(OUT_A, MEDIUM_SPEED);
            OnFwd(OUT_B, HIGH_SPEED);
            until(MotorRotationCount(OUT_B) > startingRotation + degrees);
            break;
    }

    OffEx(OUT_AB, RESET_ALL);
}

// Check so we don't pass the line
task check_line()
{
    // Set light sensor at port 3
    SetSensorLight(IN_3);

    // Constantly check the value of the light sensor
    while (true)
    {
        // Check light value
        if (Sensor(IN_3) < THRESHOLD)
        {
            // Go in reversed direction!
            // TAKE CONTROL OVER THE MOTOR

            // We need to find the target again after finishing this
            target = false;

            // Go back a little bit before turning
            RotateMotorEx(OUT_AB, HIGH_SPEED, -180, 0, true, true);
            // If the other robot is not in the range of -120 and 120 degrees
            // turn either left or right
            if (motorRotation > -120 && motorRotation < 120)
                // Random if turning left or right
                if (Random(1) == 0)
                    // Turn right
                    RotateMotorEx(OUT_AB, HIGH_SPEED, 460, -100, true, true);
                else
                    // Turn left
                    RotateMotorEx(OUT_AB, HIGH_SPEED, -460, -100, true, true);

            else
                // Turn to the direction the other robot is
                RotateMotorEx(OUT_AB, HIGH_SPEED, (460/360)*motorRotation, -100, true, true);

        }

        // Don't overload the cpu!
        Wait(50);
    }
}

task rotate_sonar()
{
    // Reset motor position
    int startingRotation = MotorRotationCount(OUT_C);

    while (true)
    {
        // Rotate left and right
        OnFwd(OUT_C, SLOW_SPEED);
        until(MotorRotationCount(OUT_C) > startingRotation + 180);
        OnFwd(OUT_C, -SLOW_SPEED);
        until(MotorRotationCount(OUT_C) < startingRotation - 180);
    }
}

task sonar()
{
    SetSensorLowspeed(IN_4);

    while(true)
    {
        // Don't overload the CPU!
        Wait(200);
        ClearScreen();
        sensorVal = SensorUS(IN_4);

        // Only detect values over the threshold
        if (sensorVal < US_THRESHOLD)
        {
            motorRotation = MotorRotationCount(OUT_C);
            target = true;
        }

        // Print values to screen
        NumOut(0, 0, sensorVal);
        NumOut(0, 10, motorRotation);
        NumOut(0, 20, MotorRotationCount(OUT_C));
    }
}

task movement()
{
    // We need to find a target before doing anything
    if (target)
    {
        // Go forward if between -10 and 10 degrees
        if(motorRotation > -10 || motorRotation < 10)
            go(FORWARD, sensorVal + 10);
        // Rotate left if positive
        else if(motorRotation > 0)
            rotate(LEFT, motorRotation);
        // Rotate right if negative
        else if(motorRotation < 0)
            // Number is negative, convert
            rotate(RIGHT, abs(motorRotation));

        // A new target has to be found!
        target = false;
    }
}

task main()
{
    // Start tasks
    Precedes(   sonar,
                rotate_sonar,
                movement,
                check_line);
}
