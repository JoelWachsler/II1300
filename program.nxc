/*
.____                            ________                             ____  ______             _______________  ____ .________
|    |    ____   ____   ____    /  _____/______  ____  __ ________   /_   |/  __  \            \_____  \   _  \/_   ||   ____/
|    |  _/ __ \ / ___\ /  _ \  /   \  __\_  __ \/  _ \|  |  \____ \   |   |>      <    ______   /  ____/  /_\  \|   ||____  \
|    |__\  ___// /_/  >  <_> ) \    \_\  \  | \(  <_> )  |  /  |_> >  |   /   --   \  /_____/  /       \  \_/   \   |/       \
|_______ \___  >___  / \____/   \______  /__|   \____/|____/|   __/   |___\______  /           \_______ \_____  /___/______  /
        \/   \/_____/                  \/                   |__|                 \/                    \/     \/           \/
*/
/**
 * Author:      Joel Wachsler
 * Date:        2015-09-18
 * Desc:        Lego group 18 robot program for "KTH DROID WARS 2015".
 *              This program has a fully functioning AI.
 *
 * Disclaimer:  You are not allowed to use this program nor copy
 *              parts of it for use in the "KTH DROID WARS 2015"
 *              without the permission of all members of
 *              Lego Group 18.
 *
 **/

// Include definitions for NXC
#include "NXCDefs.h"

// Define speeds
#define HIGH_SPEED 100
#define MEDIUM_SPEED 50
#define SLOW_SPEED 25

// Define sonar rotation
#define US_ROT 35

// Define ways
#define RIGHT 0
#define LEFT 1
#define FORWARD 2
#define BACK 3

// Define threshhold value for the light sensor
#define THRESHOLD 40

// Define sonar sensitivity range
// 110cm is a fine range for searching but not while debugging
#define US_THRESHOLD 50

// Motor rotation counter for the sonar
short motorRotation = 0;
// The range of the ultrasonic sensor if it's
// shorter than the defined range for US_THRESHOLD
unsigned short sensorVal = 0;
// Found the initial target
bool target = false;
// Checks how many turns the motor for the
// ultra sonic sensor has rotated without
// finding a target
unsigned short sonarRotationCounter = 1;
// Lock the sonar in the inital position
bool total_sonar_lock = false;
// Check target lock
bool targetLock = false;
// Idle timer
unsigned short idleTimer = 0;
// Lock all movement
bool lock_movement = false;

// TODO: PRIORITY CHECKING
// make tasks with higher priority override
// tasks/functions with lower priority

// Define all functions and task so they're
// usable by all functions
void rotate(bool direction, int deg, bool override);
void go(short way, short centimeter, bool override);
task check_line();
task rotate_sonar();
task sonar();
task random_movement();
task movement();
task strategy();
task touch_sensor();

// Tell the robot to rotate
void rotate(bool direction, int deg, bool override)
{
    // Reset idletimer
    idleTimer = 0;

    // Locks the robot from doing anything if
    // this function is called without override being true
    if (lock_movement && !override)
        return;

    // Lock sonar when going and rotating
    total_sonar_lock = true;

    // One degree is only a half one when rotating
    deg *= 2;

    // Holder for starting rotation
    int startingRotation = 0;

    // Left or Right
    // Left = true
    // Right = false
    if (direction)
    {
        startingRotation = MotorRotationCount(OUT_A);
        OnFwdSync(OUT_AB, HIGH_SPEED, -100);
        // Rotate until right rotation
        until(MotorRotationCount(OUT_A) > startingRotation + deg);
    }
    else
    {
        startingRotation = MotorRotationCount(OUT_B);
        OnFwdSync(OUT_AB, HIGH_SPEED, 100);
        // Rotate until right rotation
        until(MotorRotationCount(OUT_B) > startingRotation + deg);
    }

    // Brake the motor before exiting
    OffEx(OUT_AB, RESET_ALL);

    // Unlock sonar
    total_sonar_lock = false;
}

// Tell the robot to go in a certain way
void go(short way,  short centimeter, bool override)
{
    // Reset idletimer
    idleTimer = 0;

    if (lock_movement && !override)
        return;

    // Converting
    int degrees = 50/3 * centimeter;
    int startingRotation = MotorRotationCount(OUT_A);

    // Lock sonar when going and rotating
    total_sonar_lock = true;

    switch(way)
    {
        case FORWARD:
            // Start motor and sync them
            OnFwdSync(OUT_AB, HIGH_SPEED, 0);
            // Rotate until right rotation
            // TODO: TEST this
            until(MotorRotationCount(OUT_A) > startingRotation + degrees || !target);
            /*until(MotorRotationCount(OUT_A) > startingRotation + degrees);*/
            break;
        case BACK:
            OnFwdSync(OUT_AB, -HIGH_SPEED, 0);
            until(MotorRotationCount(OUT_A) < startingRotation - degrees);
            break;
        case LEFT:
            // TODO: MAKE LEFT AND RIGHT GO IN A CIRCLE WITH
            // A DIAMETER OF 20 CM
            OnFwd(OUT_A, HIGH_SPEED);
            OnFwd(OUT_B, MEDIUM_SPEED);
            until(MotorRotationCount(OUT_A) > startingRotation + degrees);
            break;
        case RIGHT:
            OnFwd(OUT_A, MEDIUM_SPEED);
            OnFwd(OUT_B, HIGH_SPEED);
            until(MotorRotationCount(OUT_B) > startingRotation + degrees);
            break;
    }

    // Reset rotation counter and turn off the motor
    OffEx(OUT_AB, RESET_ALL);

    // Unlock sonar
    total_sonar_lock = false;
}

// Check so we don't pass the line
task check_line()
{
    // Set light sensor at port 3
    SetSensorLight(IN_3);

    // Constantly check the value of the light sensor
    while (true)
    {
        // Don't overload the cpu!
        Wait(50);

        // Check light value
        if (Sensor(IN_3) > THRESHOLD)
            continue;

        // But this one works!!!!
        // This function is too slow!
        RotateMotorEx(OUT_AB, HIGH_SPEED, -600, 0, true, true);
        RotateMotorEx(OUT_AB, HIGH_SPEED, 360, 100, true, true);
    }
}

inline void left_right_or_lock(int startingRotation, int rotate, bool left_right)
{
    if (left_right)
    {
        OnFwd(OUT_C, US_ROT);
        until(MotorRotationCount(OUT_C) > startingRotation + rotate || total_sonar_lock);
    }
    else
    {
        OnFwd(OUT_C, -US_ROT);
        until(MotorRotationCount(OUT_C) < startingRotation - rotate || total_sonar_lock);
    }
}

task rotate_sonar()
{
    // Reset motor position
    int startingRotation = MotorRotationCount(OUT_C);
    int rotate = sonarRotationCounter * 40;

    while (true)
    {
        // Rotate a low number of degrees when locked
        while (total_sonar_lock)
        {
            OnFwd(OUT_C, -HIGH_SPEED);
            until(MotorRotationCount(OUT_C) < startingRotation + 10);

            OnFwd(OUT_C, HIGH_SPEED);
            until(MotorRotationCount(OUT_C) > startingRotation - 10);
        }

        // Calulcate turn with a maximum of 180 degrees
        rotate = (sonarRotationCounter * 40 >= 180) ? 180 : sonarRotationCounter * 40;

        // Rotate left and right
        if (Random(2) & 1)
        {
            left_right_or_lock(startingRotation, rotate, LEFT);
            left_right_or_lock(startingRotation, rotate, RIGHT);
        }
        else
        {
            left_right_or_lock(startingRotation, rotate, RIGHT);
            left_right_or_lock(startingRotation, rotate, LEFT);
        }

        // Search for more than one
        sonarRotationCounter++;
    }
}

task sonar()
{
    // The sonar can't detect in less than 150ms
    SetSensorLowspeed(IN_4);

    while(true)
    {
        // Don't overload the CPU!
        Wait(150);
        // Update sonar sensor value
        sensorVal = SensorUS(IN_4);

        // Only detect values over the threshold
        if (sensorVal > US_THRESHOLD)
        {
            // Remove the target lock
            target = false;
            continue;
        }

        // FOUND A TARGET!
        motorRotation = MotorRotationCount(OUT_C);
        target = true;
        sonarRotationCounter = 1;

        // True while looking at target
        // For dropping movement if the target
        // disappears while moving towards it
        targetLock = true;
    }
}

task random_movement()
{
    // Random timer min and max time
    unsigned short starting = 10000;
    unsigned short ending = 25000;

    // Min and max turnaround
    unsigned short start_rotation = 30;
    unsigned short end_rotation = 360;

    // Min and max go forward
    unsigned short start_forward = 5;
    unsigned short end_forward = 20;

    while (true)
    {
        // Do something random if standing still
        // for a couple of seconds
        if (idleTimer <= Random(ending-starting)+starting)
        {
            Wait(500);
            idleTimer += 500;
            continue;
        }

        // Randomizing movement when idle

        if (Random(2) & 1)
            rotate((Random(2) & 1) ? LEFT : RIGHT, Random(end_rotation-start_rotation)+start_rotation, false);
        else
            go(FORWARD, Random(end_forward-start_forward)+start_forward, false);
    }
}

task movement()
{
    Follows(strategy);

    while(true)
    {
        // We need to find a target before doing anything
        if (!target)
            continue;

        // Go forward if between -10 and 10 degrees
        if(motorRotation > -50 && motorRotation < 50)
            go(FORWARD, sensorVal + 10, false);
            // Rotate left if positive
        else if(motorRotation > 0)
            // Rotate right if negative
            rotate(LEFT, motorRotation, false);
        else if(motorRotation < 0)
            // Number is negative, convert
            rotate(RIGHT, abs(motorRotation), false);

        // A new target has to be found!
        target = false;
    }
}

task touch_sensor()
{
    SetSensorTouch(IN_1);
    SetSensorTouch(IN_2);

    while(true)
    {
        // Go forwards if sensor 1 and two are pushed in
        // Go left if sensor 1 is pushed in
        // Go right if sensor 2 is pushed in
        if (Sensor(IN_1) && Sensor(IN_2))
        {
            go(FORWARD, 30, true);
        }
        else if(Sensor(IN_1))
        {
            go(LEFT, 30, true);
        }
        else if(Sensor(IN_2))
        {
            go(RIGHT, 30, true);
        }
    }
}

task main()
{
    // Start tasks
    Precedes(
                /*strategy,*/
                /*check_line,*/
                sonar,
                rotate_sonar,
                movement,
                /*random_movement*/
                touch_sensor
            );
}
