/**
 * .____                            ________                             ____  ______             _______________  ____ .________
 * |    |    ____   ____   ____    /  _____/______  ____  __ ________   /_   |/  __  \            \_____  \   _  \/_   ||   ____/
 * |    |  _/ __ \ / ___\ /  _ \  /   \  __\_  __ \/  _ \|  |  \____ \   |   |>      <    ______   /  ____/  /_\  \|   ||____  \
 * |    |__\  ___// /_/  >  <_> ) \    \_\  \  | \(  <_> )  |  /  |_> >  |   /   --   \  /_____/  /       \  \_/   \   |/       \
 * |_______ \___  >___  / \____/   \______  /__|   \____/|____/|   __/   |___\______  /           \_______ \_____  /___/______  /
 *         \/   \/_____/                  \/                   |__|                 \/                    \/     \/           \/
 *
 * Author:      Joel Wachsler
 * Date:        2015-10-03
 * Desc:        Lego group 18 robot program for "KTH DROID WARS 2015".
 *              This program has a fully functioning AI.
 *
 * Disclaimer:  You are not allowed to use this program nor copy
 *              parts of it for use in the "KTH DROID WARS 2015"
 *              without the permission of all members of
 *              Lego Group 18.
 *
 **/

// Global speed definitions
#define HIGH_SPEED 100
#define MEDIUM_SPEED 50
#define SLOW_SPEED 25
#define US_ROTATION_SPEED 35

// Define ways
#define RIGHT 0
#define LEFT 1
#define FORWARD 2
#define BACK 3

#define MOVE 1
#define ROTATE 0

// Define priority
#define PRIO_HIGH 2
#define PRIO_MEDIUM 1
#define PRIO_LOW 0

// Define sensor threshold
#define LIGHT_THRESHOLD 40
#define US_THRESHOLD 10

// Define motor inputs
#define RIGHT_MOTOR OUT_B
#define LEFT_MOTOR OUT_A
#define BOTH_MOTORS OUT_AB
#define US_MOTOR OUT_C
#define TOUCH_LEFT IN_4
#define TOUCH_RIGHT IN_4
#define US IN_1
#define LIGHT_SENSOR IN_3

// Declare functions for usage before they're declared
task mov_finished();
task rotate_sonar();

mutex finished_mutex;
mutex sonar_reset_mutex;

struct MoveCommand
{
    bool running;
    // Priority
    unsigned short prio;
    short rotateDegreesOrCentimeters;
    // Which way to go
    unsigned short way;
    // Rotate or move command?
    // move = true
    // rotate = false
    bool moveOrRotate;
};

struct SonarValues
{
    unsigned short targetRange;
    short targetSpotDegree;
    short sonarMotorRotationValue;
    bool target;
};

struct GlobalVar
{
    MoveCommand commandRunning;
    SonarValues sonarValues;
};

GlobalVar global;

/* -------------------------------------------------- UTILS -------------------------------------------------- */

bool randomBool()
{
    return Random(2) & 1;
}

MoveCommand command(unsigned short prio, bool moveOrRotate, short rotateDegreesOrCentimeters, unsigned short way)
{
    MoveCommand command;
    command.running = true;
    command.prio = prio;
    command.rotateDegreesOrCentimeters = rotateDegreesOrCentimeters;
    command.way = way;
    command.moveOrRotate = moveOrRotate;

    return command;
}

MoveCommand commandDefault()
{
    MoveCommand command;

    command.running = false;
    command.prio = PRIO_LOW;
    command.rotateDegreesOrCentimeters = 0;
    command.way = FORWARD;
    command.moveOrRotate = MOVE;

    return command;
}

/* -------------------------------------------------- UTILS END -------------------------------------------------- */

/* -------------------------------------------------- MOVEMENT -------------------------------------------------- */

task go()
{
    // Converting
    unsigned short degrees = 50/3 * global.commandRunning.rotateDegreesOrCentimeters;
    // Save the current rotation
    short startingRotation = MotorRotationCount(RIGHT_MOTOR);

    // Don't do anything if we don't need to!
    if (global.commandRunning.rotateDegreesOrCentimeters != 0)
    {
        switch(global.commandRunning.way)
        {
            case FORWARD:
                // Start motor and sync them
                OnFwdSync(BOTH_MOTORS, HIGH_SPEED, 0);
                // Rotate until right rotation
                until(MotorRotationCount(RIGHT_MOTOR) > startingRotation + degrees);
                break;
            case BACK:
                OnFwdSync(BOTH_MOTORS, -HIGH_SPEED, 0);
                until(MotorRotationCount(LEFT_MOTOR) < startingRotation - degrees);
                break;
            case LEFT:
                // TODO: MAKE LEFT AND RIGHT GO IN A CIRCLE WITH
                // A DIAMETER OF 20 CM
                OnFwd(RIGHT_MOTOR, HIGH_SPEED);
                OnFwd(LEFT_MOTOR, MEDIUM_SPEED);
                until(MotorRotationCount(RIGHT_MOTOR) > startingRotation + degrees);
                break;
            case RIGHT:
                OnFwd(RIGHT_MOTOR, MEDIUM_SPEED);
                OnFwd(LEFT_MOTOR, HIGH_SPEED);
                until(MotorRotationCount(LEFT_MOTOR) > startingRotation + degrees);
                break;
        }
    }

    Off(BOTH_MOTORS);
    StartTask(mov_finished);
}

task rotate()
{
    // One degree is only a half one when rotating
    short degrees = global.commandRunning.rotateDegreesOrCentimeters;
    // NXC SUCKS
    degrees *= 2;

    // Declare the current rotation
    short startingRotation;

    unsigned short rotationSpeed;

    // What speed should we use?
    if (global.commandRunning.rotateDegreesOrCentimeters <= 20 && global.commandRunning.rotateDegreesOrCentimeters >= -20)
        rotationSpeed = SLOW_SPEED;
    else if (global.commandRunning.rotateDegreesOrCentimeters <= 60 && global.commandRunning.rotateDegreesOrCentimeters >= -60)
        rotationSpeed = MEDIUM_SPEED;
    else
        rotationSpeed = HIGH_SPEED;

    // Don't do anything if we don't need to!
    if (global.commandRunning.rotateDegreesOrCentimeters != 0)
    {
        if (global.commandRunning.rotateDegreesOrCentimeters >= 0)
        {
            startingRotation = MotorRotationCount(RIGHT_MOTOR);
            OnFwdSync(BOTH_MOTORS, rotationSpeed, -100);
            // Rotate until correct rotation
            until(MotorRotationCount(RIGHT_MOTOR) < startingRotation - degrees);
        }
        else
        {
            startingRotation = MotorRotationCount(LEFT_MOTOR);
            OnFwdSync(BOTH_MOTORS, rotationSpeed, 100);
            // Rotate until correct rotation
            until(MotorRotationCount(LEFT_MOTOR) < startingRotation + degrees);
        }
    }

    Off(BOTH_MOTORS);
    StartTask(mov_finished);
}

// Called when a movement task is finished
task mov_finished()
{
    Follows(go, rotate);

    Acquire(finished_mutex);

    // Reset global movement
    global.commandRunning = commandDefault();

    // Turn off motors
    Off(BOTH_MOTORS);

    Release(finished_mutex);
}

// Calculate which movement command can be
// run in the current state
safecall void movementProcessor(MoveCommand command)
{
    // Can this move command be ran?
    if (command.prio < global.commandRunning.prio)
        return;

    global.commandRunning = command;

    // Stop all movement tasks
    StopTask(go);
    StopTask(rotate);

    // Determine if this is a rotation or movement command
    if (command.moveOrRotate)
        StartTask(go);
    else
        StartTask(rotate);
}

/* -------------------------------------------------- MOVEMENT END -------------------------------------------------- */

/* -------------------------------------------------- SONAR -------------------------------------------------- */
bool checked = false;
task reset_sonar()
{
    // Only one instance can by run at a certain time
    Acquire(sonar_reset_mutex);
    // Speed of sonar
    short speed;
    // Stop rotation
    StopTask(rotate_sonar);

    while(global.commandRunning.running || MotorRotationCount(US_MOTOR) > 5 || MotorRotationCount(US_MOTOR) < -5)
    {
        // What speed should we use?
        if (MotorRotationCount(US_MOTOR) > 90 || MotorRotationCount(US_MOTOR) < -90)
            speed = 100;
        else if (MotorRotationCount(US_MOTOR) > 45 || MotorRotationCount(US_MOTOR) < -45)
            speed = 50;
        else
            speed = 20;

        // Reset sonar to inital position
        if (MotorRotationCount(US_MOTOR) < -10)
        {
            OnFwd(US_MOTOR, speed);
            until(MotorRotationCount(US_MOTOR) >= -5);
            Off(US_MOTOR);
            RotateMotor(US_MOTOR, 3, MotorRotationCount(US_MOTOR));
        }
        else if (MotorRotationCount(US_MOTOR) > 10)
        {
            OnFwd(US_MOTOR, -speed);
            until(MotorRotationCount(US_MOTOR) <= 5);
            Off(US_MOTOR);
        }
        else
        {
            // Fine adjustment
            RotateMotor(US_MOTOR, 2, MotorRotationCount(US_MOTOR));
        }
    }

    // Release this resource
    Release(sonar_reset_mutex);
}

task rotate_sonar()
{
    Follows(reset_sonar);

    unsigned short increment = 60;
    unsigned short rotationCounter = 1;
    int rotate;

    /*if (randomBool())*/
    /*{*/
    while(true)
    {
        rotate = rotationCounter * increment;
        if (rotate >= 180)
        {
            rotate = 180;
            rotationCounter = 10;
        }

        OnFwd(US_MOTOR, US_ROTATION_SPEED);
        until(MotorRotationCount(US_MOTOR) > rotate);

        OnFwd(US_MOTOR, -US_ROTATION_SPEED);
        until(MotorRotationCount(US_MOTOR) < -rotate);

        Off(US_MOTOR);

        // Update rotation counter
        rotationCounter++;
    }
}

task check_sonar_value()
{
    // The sonar can't detect in less than 150ms
    SetSensorLowspeed(US);

    short spotVal;

    while(true)
    {
        spotVal = SensorUS(US);

        // Only detect values over the threshold
        if (spotVal > US_THRESHOLD)
        {
            // We don't have a target :(
            global.sonarValues.target = false;
            if (global.commandRunning.moveOrRotate == MOVE)
                // Stop movement!
                movementProcessor(command(PRIO_LOW, MOVE, 0, FORWARD));
            continue;
        }

        // Update sonar sensor value
        global.sonarValues.targetRange = spotVal;

        // A target has been spotted!
        global.sonarValues.target = true;
        // At what degree is the target?
        global.sonarValues.targetSpotDegree = -MotorRotationCount(US_MOTOR);

        // Reset
        StartTask(reset_sonar);
    }
}

/* -------------------------------------------------- SONAR END -------------------------------------------------- */

/* -------------------------------------------------- BLACK_LINE -------------------------------------------------- */

task check_black_line()
{
    // Set light sensor at port 3
    SetSensorLight(LIGHT_SENSOR);

    // Constantly check the value of the light sensor
    while (true)
    {
        // Don't overload the cpu!
        Wait(50);

        // Check light value
        if (Sensor(LIGHT_SENSOR) > LIGHT_THRESHOLD)
            continue;

        // Go back
        movementProcessor(command(PRIO_HIGH, MOVE, 40, BACK));

        // Rotate after task before completed
        until(!global.commandRunning.running);
        movementProcessor(command(PRIO_HIGH, ROTATE, 180, 0));
    }
}

/* -------------------------------------------------- BLACK_LINE END -------------------------------------------------- */

/* -------------------------------------------------- MOVEMENT TASK -------------------------------------------------- */

task movement()
{
    while(true)
    {
        // We need to find a target before doing anything
        if (!global.sonarValues.target)
            continue;

        // Forward if the target is in a low number of degrees
        if(global.sonarValues.targetSpotDegree > -10 && global.sonarValues.targetSpotDegree < 10)
            movementProcessor(command(PRIO_LOW, MOVE, global.sonarValues.targetRange + 10, FORWARD));
        else
        {
            // Wait until command is finished
            if (global.commandRunning.running && global.commandRunning.moveOrRotate == ROTATE)
                until(!global.commandRunning.running);
            movementProcessor(command(PRIO_LOW, ROTATE, global.sonarValues.targetSpotDegree, 0));
        }
    }
}

/* -------------------------------------------------- MOVEMENT TASK END -------------------------------------------------- */

/* -------------------------------------------------- TOUCH TASK -------------------------------------------------- */

task touch_sensor()
{
    SetSensorTouch(TOUCH_LEFT);
    SetSensorTouch(TOUCH_RIGHT);

    while(true)
    {
        // Go forwards if sensor 1 and two are pushed in
        // Go left if sensor 1 is pushed in
        // Go right if sensor 2 is pushed in
        if (Sensor(TOUCH_LEFT) && Sensor(TOUCH_RIGHT))
            movementProcessor(command(PRIO_MEDIUM, MOVE, 30, FORWARD));
        else if(Sensor(TOUCH_LEFT))
            movementProcessor(command(PRIO_MEDIUM, MOVE, 30, LEFT));
        else if(Sensor(TOUCH_RIGHT))
            movementProcessor(command(PRIO_MEDIUM, MOVE, 30, RIGHT));
    }
}

/* -------------------------------------------------- TOUCH TASK END -------------------------------------------------- */

task debug()
{
    while(true)
    {
        ClearScreen();

        TextOut(0,0,"Degree:");
        NumOut(50,0,global.sonarValues.targetSpotDegree);

        TextOut(0,8,"Range:");
        NumOut(50,8,global.sonarValues.targetRange);

        TextOut(0,8*2,"US ROT:");
        NumOut(50,8*2,MotorRotationCount(US_MOTOR));

        TextOut(0,8*3,"Running:");
        NumOut(50,8*3,global.commandRunning.running);

        TextOut(0,8*4,"Target:");
        NumOut(50,8*4,global.sonarValues.target);

        TextOut(0,8*5,"Target:");
        NumOut(50,8*5,checked);

        Wait(100);
    }
}

task main()
{
    // Dummy for sonar values
    SonarValues sonarValues;
    sonarValues.target = false;
    sonarValues.targetRange = 5000;
    sonarValues.targetSpotDegree = 0;

    // NXC STILL SUCKS
    global.commandRunning = commandDefault();
    global.sonarValues = sonarValues;

    // Start threads
    Precedes(
            /*check_black_line,*/
            reset_sonar,
            check_sonar_value,
            movement,
            touch_sensor,
            debug
        );
}
